package lesson_05;

public class CharDZ {

    public static void main(String[] args) {

        char ch1 = 'o';
        char ch2 = 'l';
        char ch3 = 'y';
        char ch4 = 'a';

        ch1 = (char) (ch1 - 32); // должно быть преобразование типа так как джава думает что это инт по умолчанию

        ch2 = (char) (ch2 - 32);
        ch3 = (char) (ch3 - 32);
        ch4 = (char) (ch4 - 32);

        System.out.println("Преобразованные регистра: " + ch1 + ch2 + ch3 + ch4);


        ch1 = (char) (ch1 - 32);
        ch2 -= 32; // ch2 = ch2 -32;
        ch3 -= 32;
        ch4 -= 32;

        System.out.println("Проба: " + ch1 + ch2 + ch3 + ch4);

        System.out.println(1 + 2);
        System.out.println(1 + 2 + " hello" + 1 + 2); //  к строке прилепил символы
/*
если есть какая то колбоса внутри, метод идет слева направо и анализирует строки.
Между числами есть мат операции 1+2 получилось 3 дальше число и строка
и всегда когда будет что то + строка, вот это будет преобразовано в стринг
3 + что то(стринг) + всегда будет обозначать канкатенацию
И второй момент если есть строка и какие то типы данных:
инт дабли и т.д. строка и знак плюс все что справа больше не воспринимается как цифры. Все будет преобразовано в стринг
к хэлоу приклеивается строка 1

Было сделано преобразование
        System.out.println(3 + " hello" + "1" + "2"); //  к строке прилепил символы
после плюса автоматически все будет кантантенацией
                     2  3       4         1
 System.out.println(1 + 2 + " hello" + (1 + 2)); //  к строке прилепил символы
Поменять приоритет операции поставить скобки!! вначале сложит скобки а потом идет слева на право

 System.out.println(1 + 2 + " hello" + (x + y)); //  к строке прилепил символы

 */
        System.out.println(1 + 2 + " hello" + (1 + 2));

        int int1 = 18;
        int int2 = 15;

        System.out.println("My age: " + int1 + int2); // контонтенация
        System.out.println("My age: " + (int1 + int2)); // вычисление и потом контонтенация ( к строке прилепи то что есть в правой части
        // строк много и навыки должны быть

        String letters = "abcdefgh";
// набор символов у каждой буквы свой номер, если мы начинаем чтото считать
        // в джава все с цифры 0 1 2 3 4 5 6 7 8 9 каждая пронумерована

        /*
        Мы можем взять из строки символ по его номеру

        один чар хранит символ
Есть метод возвращающий длину строки 1 2 6 7 он выдаст какая длин номер длины всегда будет меньше на ед
         */
        char firstChar = letters.charAt(0);
        System.out.println("firstChar: " + firstChar);
        //взятие строки по номеру, взять символ по его номеру
        char lastChar = letters.charAt(letters.length() - 1);
        System.out.println("lastChar: " + lastChar);

        //   System.out.println(letters.charAt(-1));
        System.out.println(letters.charAt(7));
// если будет неверные цифры, прога завершит свое выполнение
        /*
        У нас етсь целый набор методов для символов

        index0f - ищет индекс начала вхождения подстроки в строке

                      1 2 3 4 5 6 7 8 9 10 - метод ищет есть ли в строке символ, он ищет и говорит что символ
                      находится в строке под позицией 4
                ищется начало с первого вхождения
                */
        String digits = "01234567-01-678";
        int index = digits.indexOf('4');
        System.out.println("index: " + index);


        index = digits.indexOf("679");
        System.out.println("Строка начинается с индекса 679: " + index);

        // может быть мы что то ищем а этого нет
        // если не найдет вернет -1 - так показывает что подстрока не найдена, так как ответ в виде индекса
        // может прислать только число
        index = digits.indexOf("67");
        System.out.println("Строка начинается с индекса 67: " + index);

// есть еще метод который может найти последнее вхождение ищет 67 находит запоминает и идет дальше по строке, если больше не нашел, вернет нам 6
        // если еще ищет нашел в строке под номером 11, если не нашел то может вернуть
        // есть индекс первого вхождения и последнего вхождения - справа ищет и как нашел возвращает, каждый раз обновляет,

        index = digits.lastIndexOf("67");
        System.out.println("lastIndex 67: " + index);
// в индекс можно передать строку "" а можно символ ''

// Замены таргет не изменен
        String target = "abcabeabd";
        // замена подстроки на другую
        String output = target.replace("ab", "AB");
        System.out.println("output: " + output);
//output: ABcABeABd - все вхождения наел и заменил на аб


        output = target.replaceFirst("ab", "AB");
        System.out.println("First output: " + output);

        output = target.replaceAll("ab", "AB");
        System.out.println("all outputt: " + output);

        // методы могут передавать строки, но replaceAll сюда можно передать регулярное выражение, он позволяет шаблонизировать то что ищем.
        // можно написать соответствует ли моя строка шаблону вначале 2 буквы а потом цифры. Если найдешь такой шаблон - заданому в регулярных выражениях
        // aD+ 00


        // выделение подстроки
        // Регулярные выражения: введи имейл - вот этой проверкой занимаются регулярные выражение. есть шаблон -буква собачка есть точка есть символы
        // может если чего то не хватает не дать сохранить, та же система проверяет шаблон пароля.
        //
        digits = "0123456789"; // индекс соответствует позиции


        String subString = digits.substring(2);
        System.out.println("subString: " + subString);

// а если я хочу выделить серединка ? начать со второго а закончить 5

        subString = digits.substring(2, 5); // [2, 5] возьми мне начиная со второго включительно и до 5 не включительно.
        // По факту от взял 2.3.4 и в джава так всегда первое включ в диапозон второе не включается
        // я должен писать если хочу получить до 5 (2, 6;
// что бы получить первые 4 надо указать с 0, 5 (0.1.2.3.4)
        System.out.println("subString: " + subString);
        // каждый символ имеет номер, строка состоит из символов
        // пользовательский ввод. Надо попросить данные










    }
}
